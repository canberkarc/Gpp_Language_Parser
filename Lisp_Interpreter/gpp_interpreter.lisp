; Constants for keywords,comments,values,identifiers,operators.
(defconstant DOUBLEMULT "OP_DOUBLEMULT")
(defconstant PLUS "OP_PLUS")
(defconstant MINUS "OP_MINUS")
(defconstant DIV "OP_DIV")
(defconstant MULT "OP_MULT")
(defconstant OP "OP_OP")
(defconstant CP "OP_CP")
(defconstant OC "OP_OC")
(defconstant CC "OP_CC")
(defconstant COMMA "OP_COMMA")
(defconstant LISTOP "OP_LSTOP")
(defconstant IntegerValue "IntegerValue")
(defconstant COMMENT "COMMENT")
(defconstant ID "ID")
(defconstant DEFFUN "KW_DEFFUN")
(defconstant DEFVAR "KW_DEFVAR")
(defconstant CONCAT "KW_CONCAT")
(defconstant FALSE "KW_FALSE")
(defconstant APPEND "KW_APPEND")
(defconstant WHILE "KW_WHILE") 
(defconstant EQUAL "KW_EQUAL")
(defconstant TRUE "KW_TRUE")
(defconstant DISP "KW_DISP")
(defconstant EXIT "KW_EXIT")
(defconstant LESS "KW_LESS")
(defconstant LIST "KW_LIST")
(defconstant AND "KW_AND")
(defconstant SET "KW_SET")
(defconstant SETQ "KW_SETQ")
(defconstant FOR "KW_FOR")
(defconstant NL "KW_NIL")
(defconstant NOT "KW_NOT")
(defconstant OR "KW_OR")
(defconstant IF "KW_IF")
(defconstant LOAD "KW_LOAD")

#|
    Algorithm of lexer function:
    1- Determine given character lexeme is what
    2- Append its token to token list (tokenL)
    Token list is used in parser
    3- Append character lexeme to character list (chLst)
    4- If there is any syntax error, give error

|#

;Lexer function 
(defun lexer_func(inp)
    (let( (countt 0) (paranthVal nil) (multVal nil) (idVal nil) (gLst (list )) (chLst (list )) (tokenL (list ))
        (letters '(#\. #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)) 
        (integers (list #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)) )
        
        (loop for i from 0 to (- (length inp) 1)
            do
            (setq idVal nil)
            (setq multVal nil)
            (loop while (and (or (equal (char inp i) #\Space) (equal (char inp i) #\newline) (equal (char inp i) #\tab)) (< i (- (length inp) 1)) )
                do
                (setq i (+ i 1))
            )

            ; Firstly I do character lexeme's handling (operators)
            ; add tokens of character lexemes' to token list
            ; add character lexemes to chLst
            (when (and (equal (subseq inp i (+ i 1)) "*") (equal multVal nil))
                (setq tokenL (append tokenL (list MULT)))
                (setq chLst (append chLst (list "*")))
                (setq idVal T)
            )
            (when (and (equal (subseq inp i (+ i 1)) "(") (equal paranthVal nil))
                (setq tokenL (append tokenL (list OP)))
                (setq chLst (append chLst (list "(")))
                (setq idVal T)
            )
            (when (equal (subseq inp i (+ i 1)) ")")
                (setq tokenL (append tokenL (list CP)))
                (setq chLst (append chLst (list ")")))
                (setq idVal T)
            )
            (when (equal (subseq inp i (+ i 1)) "+")
                (setq tokenL (append tokenL (list PLUS)))
                (setq chLst (append chLst (list "+")))
                (setq idVal T)
            )
            (when (equal (subseq inp i (+ i 1)) "-")
                (setq tokenL (append tokenL (list MINUS)))
                (setq chLst (append chLst (list "-")))
                (setq idVal T)
            )
            (when (equal (subseq inp i (+ i 1)) "/")
                (setq tokenL (append tokenL (list DIV)))
                (setq chLst (append chLst (list "/")))
                (setq idVal T)
            )
            
            (when (equal (subseq inp i (+ i 1)) ",")
                (setq tokenL (append tokenL (list COMMA)))
                (setq chLst (append chLst (list ",")))
                (setq idVal T)
            )
            ; OC, CC tracing
            (when (equal (subseq inp i (+ i 1)) "\"")
                (if (= (mod countt 2) 0)
                    (when t
                        (setq tokenL (append tokenL (list OC)))
                        (setq chLst (append chLst (list "\"")))
                    ) 
                (when t
                    (setq tokenL (append tokenL (list CC)))
                    (setq chLst (append chLst (list "\"")))
                )
                )
                (setq countt (+ countt 1))
                (setq idVal T)
            )

            ;I do comment handling here
            (if (<= (+ i 1) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 1)) ";")
                    (setq idVal T)
                    (setq gLst (append gLst (list chLst)))
                    (setq gLst (append gLst (list tokenL)))
                    (return-from lexer_func gLst)
                )
            )

            (if (<= (+ i 1) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 2)) "**")
                    (setq tokenL (append tokenL (list DOUBLEMULT)))
                    (setq chLst (append chLst (list "**")))
                    (setq idVal T)
                    (setq i (+ i 1))
                    (setq multVal t)
                )
            )
            (if (<= (+ i 1) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 2)) "'(")
                    (setq tokenL (append tokenL (list LISTOP)))
                    (setq chLst (append chLst (list "'(")))
                    (setq idVal T)
                    (setq i (+ i 1))
                    (setq paranthVal t)
                )
            )

            ; Secondly I do character lexeme's handling (keywords)
            (if (<= (+ i 1) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 2)) "or")
                    (let ((flag t))
                        (if (<= (+ i 2) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 2)) integers)) (not (member (char inp (+ i 2)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list OR)))
                            (setq chLst (append chLst (list "or")))
                            (setq idVal T)
                            (setq i (+ i 1))
                        )
                    )  
                )
            )
            (if (<= (+ i 1) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 2)) "if")
                    (let ((flag t))
                        (if (<= (+ i 2) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 2)) integers)) (not (member (char inp (+ i 2)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list IF)))
                            (setq chLst (append chLst (list "if")))
                            (setq idVal T)
                            (setq i (+ i 1))
                        )
                    ) 
                )
            )
            
            (if (<= (+ i 2) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 3)) "and")
                    (let ((flag t))
                        (if (<= (+ i 3) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 3)) integers)) (not (member (char inp (+ i 3)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            ;(format t "~A ~%" AND)
                            (setq tokenL (append tokenL (list AND)))
                            (setq chLst (append chLst (list "and")))
                            (setq idVal T)
                            (setq i (+ i 2))
                        )
                    )       
                )
            )
            (if (<= (+ i 2) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 3)) "not")
                    (let ((flag t))
                        (if (<= (+ i 3) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 3)) integers)) (not (member (char inp (+ i 3)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            ;(format t "~A ~%" NOT)
                            (setq tokenL (append tokenL (list NOT)))
                            (setq chLst (append chLst (list "not")))
                            (setq idVal T)
                            (setq i (+ i 2))
                        )
                    )   
                )
            )
            (if (<= (+ i 2) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 3)) "nil")
                    (let ((flag t))
                        (if (<= (+ i 3) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 3)) integers)) (not (member (char inp (+ i 3)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            ;(format t "~A ~%" NL)
                            (setq tokenL (append tokenL (list NL)))
                            (setq chLst (append chLst (list "nil")))
                            (setq idVal T)
                            (setq i (+ i 2))
                        )
                    )  
                )
            )
            (if (<= (+ i 2) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 3)) "set")
                    (let ((flag t))
                        (if (<= (+ i 3) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 3)) integers)) (not (member (char inp (+ i 3)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list SET)))
                            (setq chLst (append chLst (list "set")))
                            (setq idVal T)
                            (setq i (+ i 2))
                        )
                    )  
                )
            )
            ; Here is for assignment operation
            (if (<= (+ i 2) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 3)) "setq")
                    (let ((flag t))
                        (if (<= (+ i 3) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 3)) integers)) (not (member (char inp (+ i 3)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list SETQ)))
                            (setq chLst (append chLst (list "setq")))
                            (setq idVal T)
                            (setq i (+ i 2))
                        )
                    )  
                )
            )
            (if (<= (+ i 2) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 3)) "for")
                    (let ((flag t))
                        (if (<= (+ i 3) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 3)) integers)) (not (member (char inp (+ i 3)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list FOR)))
                            (setq chLst (append chLst (list "for")))
                            (setq idVal T)
                            (setq i (+ i 2))
                        )
                    )  
                )
            )

            (if (<= (+ i 3) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 4)) "less")
                    (let ((flag t))
                        (if (<= (+ i 4) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 4)) integers)) (not (member (char inp (+ i 4)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list LESS)))
                            (setq chLst (append chLst (list "less")))
                            (setq i (+ i 3))
                            (setq idVal T)
                        )
                    )    
                )
            )
            (when (<= (+ i 3) (- (length inp) 1)) 
                (when (equal (subseq inp i (+ i 4)) "list")
                    (let ((flag t))
                        (if (<= (+ i 4) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 4)) integers)) (not (member (char inp (+ i 4)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list LIST)))
                            (setq chLst (append chLst (list "list")))
                            (setq i (+ i 3))
                            (setq idVal T)
                        )
                    )    
                )
            )
            (if (<= (+ i 3) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 4)) "load")
                    (let ((flag t))
                        (if (<= (+ i 4) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 4)) integers)) (not (member (char inp (+ i 4)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list LOAD)))
                            (setq chLst (append chLst (list "load")))
                            (setq i (+ i 3))
                            (setq idVal T)
                        )
                    ) 
                )
            )
            (if (<= (+ i 3) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 4)) "exit")
                    (let ((flag t))
                        (if (<= (+ i 4) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 4)) integers)) (not (member (char inp (+ i 4)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list EXIT)))
                            (setq chLst (append chLst (list "exit")))
                            (setq i (+ i 3))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 3) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 4)) "disp")
                    (let ((flag t))
                        (if (<= (+ i 4) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 4)) integers)) (not (member (char inp (+ i 4)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list DISP)))
                            (setq chLst (append chLst (list "disp")))
                            (setq i (+ i 3))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 3) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 4)) "true")
                    (let ((flag t))
                        (if (<= (+ i 4) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 4)) integers)) (not (member (char inp (+ i 4)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list TRUE)))
                            (setq chLst (append chLst (list "true")))
                            (setq i (+ i 3))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 4) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 5)) "equal")
                    (let ((flag t))
                        (if (<= (+ i 5) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 5)) integers)) (not (member (char inp (+ i 5)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list EQUAL)))
                            (setq chLst (append chLst (list "equal")))
                            (setq i (+ i 4))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 4) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 5)) "false")
                    (let ((flag t))
                        (if (<= (+ i 5) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 5)) integers)) (not (member (char inp (+ i 5)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list FALSE)))
                            (setq chLst (append chLst (list "false")))
                            (setq i (+ i 4))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 4) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 5)) "while")
                    (let ((flag t))
                        (if (<= (+ i 5) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 5)) integers)) (not (member (char inp (+ i 5)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list WHILE)))
                            (setq chLst (append chLst (list "while")))
                            (setq i (+ i 4))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 5) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 6)) "append")
                    (let ((flag t))
                        (if (<= (+ i 6) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 6)) integers)) (not (member (char inp (+ i 6)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list APPEND)))
                            (setq chLst (append chLst (list "append")))
                            (setq i (+ i 5))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 5) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 6)) "concat")
                    (let ((flag t))
                        (if (<= (+ i 6) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 6)) integers)) (not (member (char inp (+ i 6)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list CONCAT)))
                            (setq chLst (append chLst (list "concat")))
                            (setq i (+ i 5))
                            (setq idVal T)
                        )
                    ) 
                )
            )
            (if (<= (+ i 5) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 6)) "deffun")
                    (let ((flag t))
                        (if (<= (+ i 6) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 6)) integers)) (not (member (char inp (+ i 6)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list DEFFUN)))
                            (setq chLst (append chLst (list "deffun")))
                            (setq i (+ i 5))
                            (setq idVal T)
                        )
                    )
                )
            )
            (if (<= (+ i 5) (- (length inp) 1))
                (when (equal (subseq inp i (+ i 6)) "defvar")
                    (let ((flag t))
                        (if (<= (+ i 6) (- (length inp) 1)) 
                            (if (and (not (member (char inp (+ i 6)) integers)) (not (member (char inp (+ i 6)) letters)))
                                (setq flag t)
                                (setq flag nil)
                            )
                        )
                        (when flag
                            (setq tokenL (append tokenL (list DEFVAR)))
                            (setq chLst (append chLst (list "defvar")))
                            (setq i (+ i 5))
                            (setq idVal T)
                        )
                    )
                )
            )
            ; Here's for handling integer values
            ; I imlemented [1-9][0-9]*|"0" here
            (when (member (char inp i) integers)
                ;Here is for "0"
                (if (<= (+ i 1) (- (length inp) 1))
                    (when (and (equal (char inp i) #\0) (not (member (char inp (+ i 1)) integers)))
                        (setq tokenL (append tokenL (list IntegerValue))) (setq chLst (append chLst (list "0"))) (setq idVal T)
                    )
                )
                (when (and (= i (- (length inp) 1)) (equal (char inp i) #\0))
                    (setq tokenL (append tokenL (list IntegerValue))) (setq chLst (append chLst (list "0"))) (setq idVal T)
                )
                ;and here is for [1-9][0-9]* 
                (let ((IntegerValueString (string "")))
                    (when (not (equal (char inp i) #\0))
                        (loop while (and (member (char inp i) integers) (<= i (- (length inp) 1)))
                            do
                            (setq IntegerValueString (concatenate 'string IntegerValueString (string (char inp i))))
                            (setq i (+ i 1))           
                        )
                        (setq tokenL (append tokenL (list IntegerValue))) (setq chLst (append chLst (list IntegerValueString)))
                        (setq i (- i 1)) (setq idVal T)
                    )
                )
            )

            ; Here is handling for identifiers 
            ; [a-zA-Z][a-zA-Z0-9]*

            (let ((idString (string "")))
                (when (and (equal idVal nil) (member (char-downcase (char inp i)) letters))
                    (loop while (and (or (member (char-downcase (char inp i)) letters) (member (char inp i) integers) ) (<= i (- (length inp) 1)))
                        do
                        (setq idString (concatenate 'string idString (string (char inp i))))
                        (setq i (+ i 1))
                    )
                    (setq tokenL (append tokenL (list ID)))
                    (setq chLst (append chLst (list idString))) (setq i (- i 1)) (setq idVal T)     
                )
            )
            ;For error case
            (when (and (equal idVal nil) (not (or (equal (char inp i) #\Space) (equal (char inp i) #\newline) (equal (char inp i) #\tab))))
                (format t "SYNTAX_ERROR IN ~A SYMBOL!~%" (char inp i))
                (return-from lexer_func)
            )
        )
        (setq gLst(append gLst (list chLst)))
        (setq gLst(append gLst (list tokenL)))
        gLst
    )
)

; Function to trace open bracket, close bracket
(defun tracePara (lst)
    (let ((countPara 0))
        (loop for i from 0 to (- (length lst) 1)
            do
            (if (or (equal (nth i lst) "(") (equal (nth i lst) "'("))
                (incf countPara 1)
            )
            (when (equal (nth i lst) ")")
                (if (= countPara 0)
                    (return-from tracePara nil)
                )
                (decf countPara 1)
            )
            (if (and (equal countPara 0) (< i (- (length lst) 1)))
                (return-from tracePara nil)
            )
        )
        (if (equal countPara 0)
            (return-from tracePara t) nil
        )
    )
)

; Parser function take tokenL that is provided by lexer function
(defun parser(tokenL)
    (let ((result nil) (errorVal t) (chars (nth 0 tokenL)) (tokens (nth 1 tokenL)))
        (when (not (tracePara chars))
            (format t "SYNTAX_ERROR Expression not recognized~%~%")
            (exit)
        )
        (if (or (equal chars nil) (equal tokens nil)) (return-from parser t))

        ; If tokens's length is 1 and 0th element of it is IntegerValue or KW_NIL or KW_FALSE or KW_TRUE or ID
        ; and 0th element of it is IntegerValue then set result to 0th element of chars
        (if (equal (length tokens) 1)
            (when (or (equal (nth 0 tokens) "IntegerValue") (equal (nth 0 tokens) "KW_NIL") (equal (nth 0 tokens) "KW_FALSE") (equal (nth 0 tokens) "KW_TRUE") (equal (nth 0 tokens) "ID"))
                (if (equal (nth 0 tokens) "IntegerValue")
                    (setq result (nth 0 chars)) )
                ; set result to t if tokens's 0th element is KW_TRUE, 
                ; set result to t if tokens's 0th element is KW_NIL or KW_FALSE
                (if (or (equal (nth 0 tokens) "KW_NIL") (equal (nth 0 tokens) "KW_FALSE")) (setq result nil) )
                (if (equal (nth 0 tokens) "KW_TRUE") (setq result t) )
                ; set result to 0th element of chars in uppercase if tokens's 0th element is UD
                (if (equal (nth 0 tokens) "ID") (setq result (string-upcase (nth 0 chars) )) )
                (setq errorVal nil)
            )
        )
        ; If tokens are OP_OP and KW_DEFVAR and KW_SET, set errorVal to nil
        ; if tokens 2nd element is ID then set syntaxError to nil
        ; and concetenate nstr with 2th element of chars
        ; if there is any syntax error then give error message
        (let ((nstr "") (syntaxError t) )
            (when (and (equal (nth 0 tokens) "OP_OP") (or (equal (nth 1 tokens) "KW_DEFVAR") (equal (nth 1 tokens) "KW_SET")))
                (setq errorVal nil)
                (when (equal (nth 2 tokens) "ID")
                    (setq syntaxError nil) (setq nstr (concatenate 'string nstr (nth 2 chars)))
                )
                (when syntaxError
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (setq syntaxError t)
                (when (or (equal (nth 3 tokens) "OP_OP") (equal (nth 3 tokens) "IntegerValue"))
                    (if (equal (nth 3 tokens) "IntegerValue")
                        (setq nstr (nth 3 chars))
                    (let ((i 3)(gLst (list ))(counter 1)(parserL ))
                        (loop while (not (equal counter 0))
                            do
                            (setq i (+ i 1))
                            (if (equal (nth i tokens) "OP_OP")
                                (incf counter 1)
                                (if (equal (nth i tokens) "OP_CP") (decf counter 1) )
                            )
                        )
                        (setq gLst(append gLst (list (subseq chars 3 (+ i 1)))))
                        (setq gLst(append gLst (list (subseq tokens 3 (+ i 1)))))
                        (setq parserL (parser gLst))
                        (if (integerp parserL)
                            (setq syntaxError nil)  (setq syntaxError t) )
                        (if (not syntaxError) 
                            (setq nstr  (write-to-string parserL))
                        (when t
                            (format t "SYNTAX_ERROR Expression not recognized~%~%")
                            (exit) )
                        )
                    )
                    )
                    (setq syntaxError nil)
                )
                (when syntaxError
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (setq result nstr)
            )   
        ) 
        ; If tokens are OP_OP and KW_DEFVAR and KW_SETQ, set errorVal to nil
        ; if tokens 2nd element is ID then set syntaxError to nil
        ; and concetenate nstr with 2th element of chars
        ; if there is any syntax error then give error message
        (let ((nstr "") (syntaxError t) )
            (when (and (equal (nth 0 tokens) "OP_OP") (or (equal (nth 1 tokens) "KW_DEFVAR") (equal (nth 1 tokens) "KW_SETQ")))
                (setq errorVal nil)
                (when (equal (nth 2 tokens) "ID")
                    (setq syntaxError nil) (setq nstr (concatenate 'string nstr (nth 2 chars)))
                )
                (when syntaxError
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (setq syntaxError t)
                (when (or (equal (nth 3 tokens) "OP_OP") (equal (nth 3 tokens) "IntegerValue"))
                    (if (equal (nth 3 tokens) "IntegerValue")
                        (setq nstr  (nth 3 chars))
                    (let ((i 3)(gLst (list ))(counter 1)(parserL ))
                        (loop while (not (equal counter 0))
                            do
                            (setq i (+ i 1))
                            (if (equal (nth i tokens) "OP_OP")
                                (incf counter 1)
                                (if (equal (nth i tokens) "OP_CP") (decf counter 1) )
                            )
                        )
                        (setq gLst(append gLst (list (subseq chars 3 (+ i 1)))))
                        (setq gLst(append gLst (list (subseq tokens 3 (+ i 1)))))
                        (setq parserL (parser gLst))
                        (if (integerp parserL)
                            (setq syntaxError nil)  (setq syntaxError t) )
                        (if (not syntaxError) 
                            (setq nstr (write-to-string parserL))
                        (when t
                            (format t "SYNTAX_ERROR Expression not recognized~%~%")
                            (exit) )
                        )
                    )
                    )
                    (setq syntaxError nil)
                )
                (when syntaxError
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (setq result nstr)
            )   
        )
        ; If tokens are OP_OP and OP_PLUS, set errorVal to nil
        ; if tokens's ith element is IntegerValue then increment nVal by ith element of chars and set syntaxError to nil
        (let ((nVal 0) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "OP_PLUS"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (setq syntaxError t)
                    (when (equal (nth i tokens) "IntegerValue")
                        (setq nVal (+ nVal (parse-integer (nth i chars))))
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP
                    (when (equal (nth i tokens) "OP_OP")
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (setq nVal (+ nVal parserL))
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                            
                        )
                    )
                    (if (equal (nth i tokens) "OP_CP")
                        (setq syntaxError nil)
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result nVal)
            )    
        )
        ; If tokens are OP_OP and OP_MINUS, set errorVal to nil
        ; if tokens's ith element is IntegerValue and i=2 then set nVal to ith element of chars
        ; else decrement nVal by ith element of chars
        ; and set syntaxError to nil
        (let ((nVal 0) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "OP_MINUS"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (equal (nth i tokens) "IntegerValue")
                        (if (= i 2)
                            (setq nVal (parse-integer (nth i chars)))
                        (setq nVal (- nVal (parse-integer (nth i chars))))
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP
                    (when (equal (nth i tokens) "OP_OP")
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (if (= index 2)
                                    (setq nVal parserL)
                                (setq nVal (- nVal parserL))
                                )
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result nVal)
            )
        )
        ; If tokens are OP_OP and OP_DIV, set errorVal to nil
        ; if tokens's ith element is IntegerValue and i=2 then set nVal to ith element of chars
        ; else divide nVal by ith element of chars
        ; and set syntaxError to nil
        (let ((nVal 0) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "OP_DIV"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (equal (nth i tokens) "IntegerValue")
                        (if (= i 2)
                            (setq nVal (parse-integer (nth i chars)))
                        (setq nVal (/ nVal (parse-integer (nth i chars))))
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP
                    (when (equal (nth i tokens) "OP_OP")
                        (let ((index i)(gLst (list ))(counter 1)(parserL))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (if (= index 2)
                                    (setq nVal parserL)
                                (setq nVal (/ nVal parserL))
                                )
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result nVal)
            )   
        )
        ; If tokens are OP_OP and OP_MULT, set errorVal to nil
        ; if tokens's ith element is IntegerValue and i=2 then set nVal to ith element of chars
        ; else multiply nVal by ith element of chars
        ; and set syntaxError to nil
        (let ((nVal 0) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "OP_MULT"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (equal (nth i tokens) "IntegerValue")
                        (if (= i 2)
                            (setq nVal (parse-integer (nth i chars)))
                        (setq nVal (* nVal (parse-integer (nth i chars))))
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP
                    (when (equal (nth i tokens) "OP_OP")
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (if (= index 2)
                                    (setq nVal parserL)
                                (setq nVal (* nVal parserL))
                                )
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result nVal)
            )   
        )
        ; If tokens are OP_OP and OP_DOUBLEMULT, set errorVal to nil
        ; if tokens's ith element is IntegerValue and i=2 then set nVal to ith element of chars
        ; else get exp of nVal by ith element of chars
        ; and set syntaxError to nil
        (let ((nVal 0) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "OP_DOUBLEMULT"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (equal (nth i tokens) "IntegerValue")
                        (if (= i 2)
                            (setq nVal (parse-integer (nth i chars)))
                        (setq nVal (expt nVal (parse-integer (nth i chars))))
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP
                    (when (equal (nth i tokens) "OP_OP")
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (if (= index 2)
                                    (setq nVal parserL)
                                (setq nVal (expt nVal parserL))
                                )
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result nVal)
            )   
        )
        ; If tokens are OP_OP and KW_AND set errorVal to nil
        ; if tokens are KW_TRUE or KW_NIL or KW_FALSE, check whether i=2,
        ; set valBool t else nil.
        ; if no then if ith token is KW_TRUE set valBool to (and valBool t), else set it to (and valBool nil)
        ; there is no syntax error in this case so set syntaxError to nil
        (let ((valBool ) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_AND"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (or (equal (nth i tokens) "KW_TRUE") (equal (nth i tokens) "KW_NIL") (equal (nth i tokens) "KW_FALSE"))
                        (if (= i 2)
                            (if (equal (nth i tokens) "KW_TRUE")
                                (setq valBool t)
                            (setq valBool nil)
                            )
                        (if (equal (nth i tokens) "KW_TRUE")
                            (setq valBool (and valBool t))
                        (setq valBool (and valBool nil))
                        )
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP
                    (when (equal (nth i tokens) "OP_OP")
                        (let ((index i)(gLst (list ))(counter 1)(parserL))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                           
                            ; Set parserL to its new version
                            (setq parserL (parser gLst))
                            
                            ; If not boolean then set syntaxError to nil
                            (if (typep parserL 'boolean)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            ; If not syntaxError and index = 2 then set valBool as parserL
                            ; else set it to (and valBool parserL)
                            (if (not syntaxError) 
                                (if (= index 2)
                                    (setq valBool parserL)
                                (setq valBool (and valBool parserL))
                                )
                            (when t
                               (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    ; Print error when there is any error
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result valBool)
            )   
        )
        ; If tokens are OP_OP and KW_OR set errorVal to nil
        ; if tokens are KW_TRUE or KW_NIL or KW_FALSE, check whether i=2,
        ; set valBool t else nil.
        ; if no then if ith token is KW_TRUE set valBool to (and valBool t), else set it to (and valBool nil)
        ; there is no syntax error in this case so set syntaxError to nil
        (let ((valBool ) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_OR"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (or (equal (nth i tokens) "KW_TRUE") (equal (nth i tokens) "KW_NIL") (equal (nth i tokens) "KW_FALSE"))
                        (if (= i 2)
                            (if (equal (nth i tokens) "KW_TRUE")
                                (setq valBool t)
                            (setq valBool nil)
                            )
                        (if (equal (nth i tokens) "KW_TRUE")
                            (setq valBool (or valBool t))
                        (setq valBool (or valBool nil))
                        )
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP 
                    (when (equal (nth i tokens) "OP_OP")
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  

                            ; Set parserL to its new version
                            (setq parserL (parser gLst))
                            ; If not boolean then set syntaxError to nil
                            (if (typep parserL 'boolean)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            ; If not syntaxError and index = 2 then set valBool as parserL
                            ; else set it to (and valBool parserL)
                            (if (not syntaxError) 
                                (if (= index 2)
                                    (setq valBool parserL)
                                (setq valBool (or valBool parserL))
                                )
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    ; Print error when there is any error
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result valBool)
            )   
        )
        ; If tokens are OP_OP and KW_NOT set errorVal to nil
        ; if tokens are KW_TRUE or KW_NIL or KW_FALSE, check whether i=2,
        ; set valBool t else nil.
        ; if no then if ith token is KW_TRUE set valBool to (and valBool t), else set it to (and valBool nil)
        ; there is no syntax error in this case so set syntaxError to nil
        (let ((valBool ) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_NOT"))
                (setq errorVal nil)
                (when (or (equal (nth 2 tokens) "KW_TRUE") (equal (nth 2 tokens) "KW_NIL") (equal (nth 2 tokens) "KW_FALSE"))
                    (if (equal (nth 2 tokens) "KW_TRUE")
                        (setq valBool nil)
                    (setq valBool t)
                    )
                    (setq syntaxError nil)
                )
                ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP 
                (when (equal (nth 2 tokens) "OP_OP")
                    (let ((index 2)(i 2)(gLst (list ))(counter 1)(parserL ))
                        (loop while (not (equal counter 0))
                            do
                            (setq i (+ i 1))
                            (if (equal (nth i tokens) "OP_OP")
                                (incf counter 1)
                                (if (equal (nth i tokens) "OP_CP")
                                    (decf counter 1)
                                )
                            )
                        )
                        (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                        (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                        
                        ; Set parserL to its new version
                        (setq parserL (parser gLst))
                        ; If not boolean then set syntaxError to nil
                        (if (typep parserL 'boolean)
                            (setq syntaxError nil)
                        (setq syntaxError t)
                        )
                        ; If not syntaxError and index = 2 then set valBool as parserL
                        ; else set it to (and valBool parserL)
                        (if (not syntaxError) 
                            (setq valBool (not parserL))
                        (when t
                            (format t "SYNTAX_ERROR Expression not recognized~%~%")
                            (exit)
                        )
                        )
                        
                    )
                )
                (if (equal (nth 2 tokens) "OP_CP") 
                    (setq syntaxError nil)
                )
                ; Print error when there is any error
                (when syntaxError
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (setq result valBool)   
            )
        )
        ; If tokens are OP_OP and KW_EQUAL set errorVal to nil
        ; if tokens are KW_TRUE or KW_NIL or KW_FALSE, check whether i=2,
        ; set valBool t else nil.
        ; if no then if ith token is KW_TRUE set valBool to (and valBool t), else set it to (and valBool nil)
        ; there is no syntax error in this case so set syntaxError to nil
        (let ((valBool ) (syntaxError t) (valCounter 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_EQUAL"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (or (equal (nth i tokens) "KW_TRUE") (equal (nth i tokens) "KW_NIL") (equal (nth i tokens) "KW_FALSE"))
                        (incf valCounter 1)
                        (if (= i 2)
                            (if (equal (nth i tokens) "KW_TRUE")
                                (setq valBool t)
                            (setq valBool nil)
                            )
                        (if (equal (nth i tokens) "KW_TRUE")
                            (setq valBool (equal valBool t))
                        (setq valBool (equal valBool nil))
                        )
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter value by 1 if token is IntegerValue
                    ;  and if i = 2, set valBool to ith element of chars
                    ; else set it to result of this : (equal valBool (parse-integer (nth i chars)))
                    (when (equal (nth i tokens) "IntegerValue") 
                        (incf valCounter 1)
                        (if (= i 2)
                            (setq valBool (parse-integer (nth i chars)))
                        (setq valBool (equal valBool (parse-integer (nth i chars))))
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP 
                    (when (equal (nth i tokens) "OP_OP")
                        (incf valCounter 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            ; Set parserL to its new version
                            (setq parserL (parser gLst))
                            ; If any of conditions in if is true and  boolean then set valBool parserL
                            ; else set it to result of (equal valBool parserL)
                            ; syntaxError to nil
                            (if (or (equal valBool nil) (and (typep parserL 'boolean) (typep valBool 'boolean)) (and (integerp parserL) (integerp valBool )))
                                (when t
                                    (if (= index 2)
                                        (setq valBool parserL)
                                    (setq valBool (equal valBool parserL))
                                    )
                                    (setq syntaxError nil)
                                )
                                
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    (when (or syntaxError (> valCounter 2))
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result valBool)
            )   
        )
        ; If tokens are OP_OP and KW_LESS set errorVal to nil
        ; if ith value of token is IntegerValue, increment counter value by 1
        ; check whether i=2, set valBool to ith element of chars
        ; if i!=2 then set valBool to result of (< valBool (parse-integer (nth i chars)))
        ; there is no syntax error in this case so set syntaxError to nil
        (let ((valBool ) (syntaxError t) (valCounter 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_LESS"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (equal (nth i tokens) "IntegerValue") 
                        (incf valCounter 1)
                        (if (= i 2)
                            (setq valBool (parse-integer (nth i chars)))
                        (setq valBool (< valBool (parse-integer (nth i chars))))
                        )
                        (setq syntaxError nil)
                    )
                    ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP 
                    (when (equal (nth i tokens) "OP_OP")
                        (incf valCounter 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            ; Set parserL to its new version
                            (setq parserL (parser gLst))
                            ; If not integer then set syntaxError to nil
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (if (= index 2)
                                    (setq valBool parserL)
                                (setq valBool (< valBool parserL))
                                )
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    (when (or syntaxError (> valCounter 2))
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (if (= valCounter 1)
                    (setq result t)
                (setq result valBool)
                )  
            )   
        )
        ; If tokens are OP_OP and KW_LIST  or OP_LSTOP set errorVal to nil
        ; if 0th value of token is OP_LSTOP, set startInd to 1 else set startInd to 2
        ; in loop, when ith value of tokens is IntegerValue, append to listVal ith element of chars as list and set syntaxError to nil
        ; if ith element of tokens equal to OP_CP then set syntaxError to nil
        ; if there is any syntax error then print error message
        (let ((listVal (list )) (syntaxError t) (startInd ))
            (when (or (equal (nth 0 tokens) "OP_LSTOP") (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_LIST")))
                (setq errorVal nil)
                (if (equal (nth 0 tokens) "OP_LSTOP")
                    (setq startInd 1)
                (setq startInd 2)
                )
                (loop for i from startInd to (- (length chars) 1)
                    do
                    (setq syntaxError t)
                    (when (equal (nth i tokens) "IntegerValue") 
                        (setq listVal (append listVal (list (parse-integer (nth i chars)))))
                        (setq syntaxError nil)
                    )
                    (if (equal (nth i tokens) "OP_CP")
                        (setq syntaxError nil)
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result listVal)
            )
        )

        ; If tokens are ID and OP_LSTOP  or OP_OP set errorVal to nil and print 1st element of chars as ID
        ; if 0th value of token is OP_LSTOP, set startInd to 1 else set startInd to 2
        ; in loop, when ith value of tokens is OP_OP or i+1st value of tokens is KW_CONCAT
        ; ith value of tokens is OP_OP and i+1st value of tokens is KW_APPEND
        ; ith value of tokens is OP_LSTOP
        ; then in other loop increment i, if ith value of tokens is OP_OP or ith value of tokens is OP_LSTOP, increment counter by one
        ; if ith value of tokens is OP_CP
        ; if there is any syntax error then print error message, decrement counter by 1
        (let ((listVal ) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "ID") (or (equal (nth 2 tokens) "OP_OP") (equal (nth 2 tokens) "OP_LSTOP")))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (or (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_CONCAT")) 
                          (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_APPEND"))
                          (equal (nth i tokens) "OP_LSTOP"))
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (listp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (setq listVal (append listVal parserL))
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                        (setq syntaxError nil)
                    )

                    (if (equal (nth i tokens) "OP_CP")
                        (setq syntaxError nil)
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                    
                )
                (setq result listVal)
            )
        )
        ; If tokens are OP_OP and ID and not OP_OP  OP_LSTOP then  errorVal to nil
        ; in loop, when ith value of tokens is ID, set listVal to ith value of chars
        ; if ith element of tokens equal to OP_CP then set syntaxError to nil
        ; if there is any syntax error then print error message
        (let ((listVal (list )) (syntaxError t))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "ID") (not (or (equal (nth 2 tokens) "OP_OP") (equal (nth 2 tokens) "OP_LSTOP"))))
                (setq errorVal nil)
                (loop for i from 1 to (- (length chars) 1)
                    do
                    (setq syntaxError t)
                    (when (equal (nth i tokens) "ID") 
                        (setq listVal (append listVal (list (nth i chars))))
                        (setq syntaxError nil)
                    )
                    (if (equal (nth i tokens) "OP_CP")
                        (setq syntaxError nil)
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (setq result listVal)
            )
        )
        ; If tokens are OP_OP and KW_CONCAT or OP_OP and KW_APPEND or ith value of tokens is OP_LSTOP then increment counter val by 1
        ; in loop, when ith value of tokens is ID, set listVal to ith value of chars
        ; in other loop, if ith element of tokens equal to OP_OP or ith element of tokens equal to OP_LSTOP, increment i by 1
        ; if ith element of tokens equal to OP_CP, decrement i by 1
        ; if there is any syntax error then print error message
        (let ((listVal (list ) ) (syntaxError t) (valCounter 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_CONCAT"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (or (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_CONCAT")) 
                          (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_APPEND"))
                          (equal (nth i tokens) "OP_LSTOP"))
                        (incf valCounter 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (listp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (setq listVal (append listVal parserL))
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                        (setq syntaxError nil)
                    )
                    (when (or syntaxError (> valCounter 2))
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (if (= valCounter 1)
                    (setq result t)
                (setq result listVal)
                )  
            )   
        )
        (let ((listVal (list ) ) (syntaxError t) (explistFlag 0) (expiFlag 0) (index1 -1) (index2 -1) )
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_APPEND"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (and (equal (nth i tokens) "OP_OP") (not (or (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_CONCAT")) 
                          (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_APPEND"))
                          (equal (nth i tokens) "OP_LSTOP"))))
                        (setq index1 i)
                        (incf expiFlag 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (setq listVal (append listVal (list parserL)))
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                        (setq syntaxError nil)
                    )
                    (when (equal (nth i tokens) "IntegerValue")
                        (setq index1 i)
                        (incf expiFlag 1)
                        (setq syntaxError nil)
                        (setq listVal (append listVal (list (parse-integer (nth i chars)))))
                    )
                    (when (or (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_CONCAT")) 
                          (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_APPEND"))
                          (equal (nth i tokens) "OP_LSTOP"))
                        (incf explistFlag 1)
                        (setq index2 i)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (listp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError) 
                                (setq listVal (append listVal parserL))
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                        (setq syntaxError nil)
                    )
                    (when (or syntaxError (> expiFlag 1) (> explistFlag 1))
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (when (or (not (= expiFlag 1)) (not (= explistFlag 1)) (<= index2 index1))
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (setq result listVal)
            )   
        )
        (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_EXIT") (equal (nth 2 tokens) "OP_CP") )
            (setq result "Bye.")
            (setq errorVal nil)
        )
        (when (and (equal (nth 0 tokens) "OP_OP") 
            (equal (nth 1 tokens) "KW_LOAD") 
            (equal (nth 2 tokens) "OP_OC")
            (equal (nth 3 tokens) "ID")
            (equal (nth 4 tokens) "OP_CC")
            (equal (nth 5 tokens) "OP_CP") )
            ;(print (load (nth 3 chars)))
            (setq result (nth 3 chars))
            (setq errorVal nil)
        )
        ; If tokens are OP_OP and KW_DEFFUN and ID then set errorVal to nil, set idSum to 2th element of chars
        ; in loop, when ith value of tokens is OP_OP and i+1st value of tokens is ID, set idFindInd to i, increment syntax error count by 1
        ; when ith value of tokens is OP_OP and i+1st value of tokens is KW_CONCAT or 
        ; ith value of tokens is OP_OP and i+1st value of tokens is KW_APPEND or ith value of tokens is OP_LSTOP, set explistFindInd to i,
        ; and increment syntaxErrorCLst by 1
        ; in other loop, if ith element of tokens equal to OP_OP or ith element of tokens equal to OP_LSTOP, increment i by 1
        ; if ith element of tokens equal to OP_CP, decrement i by 1
        ; if there is any syntax error then print error message
        (let ((idSum "") (syntaxErrCID 0) (syntaxErrorCLst 0) (idFindInd 0) (explistFindInd 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_DEFFUN") (equal (nth 2 tokens) "ID"))
                (setq errorVal nil)
                (setq idSum  (nth 2 chars))
                (loop for i from 3 to (- (length chars) 1)
                    do
                    (when (and (equal (nth i tokens) "OP_OP") (equal (nth (+ 1 i) tokens) "ID"))
                        (setq idFindInd i)
                        (incf syntaxErrCID 1)
                    )
                    (when (or (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_CONCAT")) 
                          (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_APPEND"))
                          (equal (nth i tokens) "OP_LSTOP"))
                        (setq explistFindInd i)
                        (incf syntaxErrorCLst 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (listp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (when syntaxError
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                        )
                    )
                )
                (when (or (> syntaxErrorCLst 1) (> syntaxErrCID 1) (> idFindInd explistFindInd) (equal idFindInd 0) (equal explistFindInd 0))
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (setq result idSum)
            )
        )
        ; If tokens are OP_OP and KW_IF or KW_WHILE set errorVal to nil
        ; if tokens are KW_TRUE or KW_NIL or KW_FALSE and if 2nd element of tokens is KW_TRUE, set valBool to t
        ; else set it to nil
        (let ((valBool ) (listVal ) (syntaxError t) (explist1 nil) (explist2 nil) (explistFlag 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (or (equal (nth 1 tokens) "KW_IF") (equal (nth 1 tokens) "KW_WHILE")))
                (setq errorVal nil)
                (when (or (equal (nth 2 tokens) "KW_TRUE") (equal (nth 2 tokens) "KW_NIL") (equal (nth 2 tokens) "KW_FALSE"))
                    (if (equal (nth 2 tokens) "KW_TRUE")
                        (setq valBool t)
                    (setq valBool nil)
                    )
                )
                ; Here increment counter by 1 if token is OP_OP, decrement counter by 1 if token is OP_CP 
                (when (equal (nth 2 tokens) "OP_OP")
                    (let ((index 2)(i 2)(gLst (list ))(counter 1)(parserL ))
                        (loop while (not (equal counter 0))
                            do
                            (setq i (+ i 1))
                            (if (equal (nth i tokens) "OP_OP")
                                (incf counter 1)
                                (if (equal (nth i tokens) "OP_CP")
                                    (decf counter 1)
                                )
                            )
                        )
                        (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                        (setq gLst(append gLst (list (subseq tokens index (+ i 1))))) 
                        (setq parserL (parser gLst))
                        (if (typep parserL 'boolean)
                            (setq syntaxError nil)
                        (setq syntaxError t)
                        )
                        (if (not syntaxError) 
                            (if (= index 2)
                                (setq valBool parserL)
                            (setq valBool (or valBool parserL))
                            )
                        (when t
                            (format t "SYNTAX_ERROR Expression not recognized~%~%")
                            (exit)
                        )
                        )
                    )
                )
                (when (not (or (equal (nth 2 tokens) "OP_OP") (equal (nth 2 tokens) "KW_TRUE") (equal (nth 2 tokens) "KW_NIL") (equal (nth 2 tokens) "KW_FALSE")) ) 
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (or (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_CONCAT")) 
                          (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_APPEND"))
                          (equal (nth i tokens) "OP_LSTOP"))
                        (incf explistFlag 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (listp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError)
                                (if (= explistFlag 1)
                                    (setq explist1 (append listVal parserL))
                                    (if (= explistFlag 2)
                                        (setq explist2 (append listVal parserL))
                                    )
                                ) 
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                )
                (when (or (= explistFlag 0) (> explistFlag 2))
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                (if valBool
                    (setq result explist1)
                (setq result explist2)
                )
            )   
        )
        (let ((nVal )(expCounter 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_DISP"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (and  (equal (nth i tokens) "OP_OC")
                        (equal (nth (+ 1 i) tokens) "ID")
                        (equal (nth (+ 2 i) tokens) "OP_CC")
                        (incf expCounter 1)
                        (setq nVal (nth (+ 1 i) chars)))
                    )
                    (when (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                        (incf expCounter 1)
                        (let ((index i)(gLst (list ))(counter 1))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq nVal (parser gLst))
                        )
                    )
                    (when (or (equal (nth i tokens) "KW_TRUE") (equal (nth i tokens) "KW_NIL") (equal (nth i tokens) "KW_FALSE"))
                        (incf expCounter 1)
                        (if (equal (nth i tokens) "KW_TRUE")
                            (setq nVal t)
                        (setq nVal nil)
                        )
                    )
                    (when (equal (nth i tokens) "IntegerValue")
                        (incf expCounter 1)
                        (setq nVal (parse-integer (nth i chars) ))
                    )
                )
                (when (> expCounter 1)
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )   
                (setq result nVal)
            )
        )
        (let ((nVal )(expCounter 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_DISP"))
                (setq errorVal nil)
                (loop for i from 2 to (- (length chars) 1)
                    do
                    (when (and  (equal (nth i tokens) "OP_OC")
                        (equal (nth (+ 1 i) tokens) "ID")
                        (equal (nth (+ 2 i) tokens) "OP_CC")
                        (incf expCounter 1)
                        (setq nVal (nth (+ 1 i) chars)))
                    )
                    (when (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                        (incf expCounter 1)
                        (let ((index i)(gLst (list ))(counter 1))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq nVal (parser gLst))
                        )
                    )
                    (when (or (equal (nth i tokens) "KW_TRUE") (equal (nth i tokens) "KW_NIL") (equal (nth i tokens) "KW_FALSE"))
                        (incf expCounter 1)
                        (if (equal (nth i tokens) "KW_TRUE")
                            (setq nVal t)
                        (setq nVal nil)
                        )
                    )
                    (when (equal (nth i tokens) "IntegerValue")
                        (incf expCounter 1)
                        (setq nVal (parse-integer (nth i chars) ))
                    )
                )
                (when (> expCounter 1)
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )   
                (setq result nVal)
            )
        )
        (let ((listVal 0) (syntaxError t)(i )(parCounter 0)(expiCounter 0)(explistFlag 0))
            (when (and (equal (nth 0 tokens) "OP_OP") (equal (nth 1 tokens) "KW_FOR") 
                    (equal (nth 2 tokens) "OP_OP") (equal (nth 3 tokens) "ID"))
                (setq errorVal nil)
                (setq i 4)
                (incf parCounter 1)
                (loop while (and (not (equal parCounter 0)) (< i (- (length chars) 1))) 
                    do
                    (when (equal (nth i tokens) "IntegerValue")
                        (incf expiCounter 1)
                        (setq syntaxError nil)
                    )
                    (if (equal (nth i tokens) "OP_CP")
                        (decf parCounter 1)
                        (setq syntaxError nil)
                    )
                    (when (equal (nth i tokens) "OP_OP")
                        ;(incf parCounter 1)
                        (incf expiCounter 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (equal (nth i tokens) "OP_OP")
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (integerp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (when syntaxError
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                        )
                        (setq syntaxError nil)
                    )
                    (when syntaxError
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                    (incf i 1)
                )
                (if (= expiCounter 2)
                    (when (or (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_CONCAT")) 
                          (and (equal (nth i tokens) "OP_OP") (equal (nth (+ i 1) tokens) "KW_APPEND"))
                          (equal (nth i tokens) "OP_LSTOP"))
                        (incf explistFlag 1)
                        (let ((index i)(gLst (list ))(counter 1)(parserL ))
                            (loop while (not (equal counter 0))
                                do
                                (setq i (+ i 1))
                                (if (or (equal (nth i tokens) "OP_OP") (equal (nth i tokens) "OP_LSTOP"))
                                    (incf counter 1)
                                    (if (equal (nth i tokens) "OP_CP")
                                        (decf counter 1)
                                    )
                                )
                            )
                            (setq gLst(append gLst (list (subseq chars index (+ i 1)))))
                            (setq gLst(append gLst (list (subseq tokens index (+ i 1)))))  
                            (setq parserL (parser gLst))
                            (if (listp parserL)
                                (setq syntaxError nil)
                            (setq syntaxError t)
                            )
                            (if (not syntaxError)
                                (setq listVal parserL)
                            (when t
                                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                                (exit)
                            )
                            )
                        )
                    )
                    (when t
                        (format t "SYNTAX_ERROR Expression not recognized~%~%")
                        (exit)
                    )
                )
                (if (and (= explistFlag 1) (= i (- (length chars) 2)))
                    (setq result listVal)
                (when t
                    (format t "SYNTAX_ERROR Expression not recognized~%~%")
                    (exit)
                )
                )
            )   
        )
        (if errorVal
            (when t
                (format t "SYNTAX_ERROR Expression not recognized~%~%")
                (exit)
            )
        result
        )
    )
)

;Get input from user and process user input
(defun terminal-process ()
    (let ((inp "")(ind 0)(result )(tokenL ))
        (loop while (not (equal inp " ")) 
            do
            (setq inp (concatenate 'string (read-line) " "))
            (setq tokenL (lexer_func inp))
            (setq result (parser tokenL))
            (when (and(not (equal result "SYNTAX_ERROR Expression not recognized~%~%")) (not (equal inp " ")))
                (format t "Syntax OK.~%")
                (format t "Result:~A~%~%" result) 
            )
            (incf ind 1)
        )
    )
)

;Function runs lexer_func for the file.
(defun file-process (filename)
    (let ((word-list (list )) (tokenL ) (result ))
        (with-open-file (file-stream filename)
            (when file-stream
                (loop for line = (read-line file-stream nil)
                    while line 
                        do 
                        (setq tokenL (lexer_func (concatenate 'string line " ")))
                        (setq result (parser tokenL))
                        (when (not (equal result "SYNTAX_ERROR Expression not recognized~%~%"))
                            (format t "Syntax OK.~%")
                            (format t "Result:~A~%~%" result) 
                        )
                )
                (close file-stream)
            )
        )
    )
)

;This function runs the interpreter with file(1 input) or with input stream(0 input).
(defun gppinterpreter( &optional filename )
    (if (equal filename nil)
        (terminal-process)
    (file-process filename)
    )
)

;Main function
; If no parameter is given then run interpreter
; else read file and process contents
(defun main ()
    (if (null *args*)
        (gppinterpreter)
        (gppinterpreter (car *args*))
    )
)

(main)